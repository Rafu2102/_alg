# 八皇后問題（N-Queens）Python 計劃

## 1. 題目描述
八皇后問題：在 8×8 的棋盤上放置 8 個皇后，使得任兩個皇后都不互相攻擊。  
皇后的攻擊規則：同一行、同一列、同一斜線（↘↗）都算攻擊。

本專案將以 **Python** 解「八皇后（可擴充成 N 皇后）」問題，並用四種方法完成：
- 改良法（問題建模 + 約束簡化 / Min-Conflicts 改良搜尋）
- 爬山算法（Hill Climbing）
- 貪婪法（Greedy / 逐列放置 + 最少衝突選擇）
- 急劇下降法（Gradient Descent 思維：用「衝突數」當損失函數做下降）

> 註：八皇后是離散問題，沒有真正可微分的梯度；「急劇下降法」用的是 **梯度下降的精神**（沿著讓 loss 減少最快的方向更新）。

---

## 2. 目標
1. 實作 N-Queens 的狀態表示與衝突計算（loss function）
2. 實作四種搜尋/最佳化策略
3. 比較它們的成功率、步數、時間
4. 輸出解法棋盤（可視化）

---

## 3. 狀態表示（State Representation）
使用一個長度為 N 的陣列 `state`：
- `state[col] = row`
- 表示「第 col 欄的皇后放在 row 這一列」

好處：
- **每欄固定一個皇后** → 天生不會有「同欄衝突」
- 只需要處理：
  - 同列衝突（row 相同）
  - 斜線衝突（|r1-r2| == |c1-c2|）

---

## 4. 損失函數（Loss / Conflict Count）
定義 `conflicts(state)` 回傳「互相攻擊的皇后對數」。  
目標是讓：
- `conflicts(state) == 0` 代表找到合法解

這個 conflicts 就是我們的「誤差 / loss」。

---

## 5. 方法設計

### A. 改良法（Min-Conflicts：改良的局部搜尋）
核心概念：
1. 先隨機生成一個 state
2. 反覆挑出「衝突最多的皇后」
3. 把它移到「衝突最少的 row」
4. 重複直到 conflicts = 0 或超過步數

特點：
- N-Queens 的經典高效做法之一
- 對大 N 通常也很快

---

### B. 爬山算法（Hill Climbing）
核心概念：
- 從初始 state 出發
- 看鄰居（neighbors）：例如把某一欄皇后移到其他 row
- 選擇讓 conflicts 最下降的鄰居
- 若沒有更好的鄰居，代表卡住（local minima）→ 可加「隨機重啟」

特點：
- 直觀，但容易卡住
- 常搭配 random restart

---

### C. 貪婪法（Greedy：逐欄/逐列放置）
核心概念（可擇一實作）：
- 逐欄放置：第 0 欄到第 N-1 欄
- 每次選擇「當下衝突最少」的位置
- 若後面無法放，可能需要回溯（若純貪婪就直接失敗）

兩種版本：
- **純貪婪**：快但可能失敗
- **貪婪 + 回溯**：幾乎保證找到（但變成 DFS/Backtracking）

本計劃採：**純貪婪（展示貪婪特性）**，並用多次重試提高成功率。

---

### D. 急劇下降法（Gradient Descent 思維的下降法）
因為離散不可微，我們採「最大下降（steepest descent）」精神：
1. 定義 loss = conflicts(state)
2. 在所有鄰居中挑選 **loss 降最多** 的那一步（最陡下降）
3. 更新 state
4. 若無法下降 → 隨機擾動/重啟（避免卡住）

特點：
- 和 Hill Climbing 很像，但更強調「一次走最大下降幅度」
- 適合寫成「梯度下降類比」的報告

---